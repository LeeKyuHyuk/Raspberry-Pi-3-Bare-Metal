Tutorial 02 - Multicore C
=========================

이제 좀 더 복잡한 것을 시도해봅시다. 여러 코어가 동작하면 복잡하기 때문에 첫 번째 튜토리얼과 같이 CPU 코어를 중지해야 합니다. 이번에는 4개의 코어 중에 1~3번 코어를 중지해보겠습니다.

시작
-----

이제 우리는 코어를 구별해야 합니다. 이를 위해 [`mpidr_el1`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0500j/BABHBJCI.html) 시스템 레지스터를 읽습니다. [`start.S`](https://github.com/LeeKyuHyuk/Raspberry-Pi-3-Bare-Metal/blob/master/02_multicorec/start.S)의 코드를 보면, `0`이 아닌 경우 무한 루프를 수행합니다. `0`이면 C의 `main` 함수를 호출합니다. `main` 함수를 호출하기 위해서는 적절한 스택이 필요하며, 호출 명령 전에 메모리에서 `0`으로 된 bss 세그먼트(Segment)가 필요합니다. 이 작업을 수행하기 위해 어셈블리에 코드를 더 추가했습니다. 그리고 C 코드가 반환되지 않으면(반환되면 안 됩니다) 다른 CPU 코어들은 무한 루프로 점프합니다.

참고: `config.txt`에 따라 응용 프로그램 코어가 중지되었을 수 있습니다. 이 경우 코드는 코어 0에서만 실행되지만, 코어 번호를 확인해도 아무런 문제는 없습니다. 다른 코어를 시작하려면, `0xE0`, `0xE8`, `0xF0` (각 코어에 대해 하나의 주소 순서로)에서 실행할 함수의 주소를 작성해야 합니다. [armstub8.S](https://github.com/raspberrypi/tools/blob/master/armstubs/armstub8.S#L129)를 보세요.

Makefile
--------

조금 까다로워졌습니다. C 소스를 컴파일하는 명령을 추가했지만, 복잡한 방식으로 추가했습니다. 이제부터는 C 소스의 개수와 관계없이 모든 튜토리얼에 동일한 `Makefile`을 사용할 수 있으므로 더 이상 설명하지 않겠습니다.

Linker script
-------------

마찬가지로 C에는 data 및 bss 섹션이 필요하므로, 링커 스크립트도 더욱 복잡해졌습니다. 또한 더 이상 번거로움 없이 어셈블리에서 참조할 수 있도록 bss 크기에 대한 계산을 추가했습니다.

어셈블리 코드로 text 세그먼트를 시작하는 것이 중요합니다. 스택 바로 앞에 스택을 설정했기 때문에 `KEEP()`입니다. 이 방법으로 우리의 로드 주소는 `0x80000`이며, `_start` 레이블은 스택 상단과 동일합니다.

Main
----

비어있는 루프이지만, 우리의 첫 번째 C 코드입니다! :-)
